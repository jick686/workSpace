JVM
 JVM内存结构：
 	方法区： 加载Class文件时，会将类的信息存入方法区
 	Heap【堆】: 存放对象，不再使用的对象会在内存不足时由垃圾回收器进行回收
 	程序计数器: 存放调用方法的指令行号
 	JVM stacks 虚拟机栈 存放局部变量，方法参数
 	本地方法栈 非java实现的调用

 调用方法时，先要到方法区获得该方法的字节码指令，由解释器将字节码指令解释为机器码执行
 并且会将指令行号读到程序计数器，当发生了线程切换，恢复时可以从中断的行号继续

 	不会出现内存溢出的区域--程序计数器
 	出现 OutOfMemoryError 的情况：
 		1. 堆内存耗尽
 			场景： 对象越来越多，有一直被使用，无法被垃圾回收
 		2. 方法区内存耗尽
 			场景： 加载的类越来越多
 		3. 虚拟机栈累积
 			场景： 每个线程最多会占用1M内存， 线程越来越多，又长时间运行不销毁
 	出现 StackOverflowError 的情况：
 		JVM虚拟机栈
 			场景： 有方法递归调用未正确结束，反序列化JSON时循环引用

方法区：
	JVM中的一块内存区域，存储类的元数据，方法字节码，即时编译器需要的信息
永久代：
元空间： 内存释放以类加载器为单位， 也就是堆中类加载器内存释放时，对应的元空间中的类元信息也会被释放

JVM内存参数：
	Xms 最小堆内存 
	Xmx 最大堆内存
	通常这两者设置为大小相等（不需要保留内存，不需要从小到大的增长）
	XX:NewSize  XX:MaxNewSize 设置新生代最小和最大值  不建议设置，JVM自己控制
	Xmn 设置新生代大小 相当于同时设置了上面的两个 并且值相等
	XX:NewRatio=2:1 表示老年代占用2份，新生代占用1份
	XX:SurvivorRatio=4:1 表示新生代分成6份，伊甸园占4份， from和to各一份

垃圾回收算法：
	标记清除法：
		1. 首先找到GC Root对象（那些一定不会被回收的对象 比如： 执行的方法内局部变量引用的对象，静态变量引用的对象）
		2. 然后沿着GC Root对象链路找， 直接或间接引用到的对象加上标记
		3. 释放未加标记的对象占用的内存
	这种方法会产生内存碎片

	标记整理法：
		比上面多了一步整理的动作，将存活对象向一端移动，可以避免内存碎片产生
	缺点 性能会比较慢


	标记复制法:
		1. 将整个内存分为两个大小相等的区域，from和to 其中to总是处于空闲， from存储新创建的对象
		2. 标记算法跟前面一致
		3. 在找出存活对象后，会将她们从from复制到to区域，复制的过程中自然完成了碎片整理
		4. 复制完成后，交换from和to的位置
	缺点： 占用双倍的空间

	GC【垃圾回收器】与分代回收算法
		GC目的： 实现无用对象内存自动释放，减少内存碎片，加快分配速度

		GC要点：
			1. 回收区域是堆内存，不包括虚拟机栈
			2. 判断无用对象，使用可达性分析算法，三色标记法标记存活对象，回收未标记对象
			3. GC大都采用分代回收思想
				分代回收思想:
					大部分对象朝生夕死，用完立刻被回收，另有少部分对象会长时间存活，每次很难回收
					根据这两类对象的特性分为新生代和老年代
				新生代采用标记复制法，老年代采用标记整理法

		三色标记
			用三种颜色记录对象的标记状态
			黑-已标记/白-还未标记/灰-标记中

		如何解决并发标记下的漏标问题 两种解决方法：
			1. 增量更新法，拦截每次赋值动作，只要赋值发生，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍
			2. SATB原始快照法 拦截每次赋值动作，不过记录的对象不同，也需要在重新标记阶段对这些对象二次处理

	Parallel GC
		1. eden内存不足发生Minor GC， 采用标记复制算法，需要暂停用户线程
		2. old内存不足发生Full GC， 采用垃圾整理算法，需要暂停用户线程

	ConcurrentMarkSweep GC
		1. 工作在old老年代，支持并发标记 采用并发清除算法
		2. 并发标记时不需要暂停用户线程
		3. 重新标记时仍需暂停用户线程
		4. 如果并发失败（回收速度赶不上新建对象速度）出发Full GC

	G1 GC
		1. 划分成多个区域
		2. 分成三个阶段：新生代回收，并发标记，混合收集
		3. 如果并发失败，出发Full GC

导致内存溢出的几种情况：
	1. 误用线程池导致内存溢出
	2. 查询数据量太大导致
	3. 动态生成类导致

